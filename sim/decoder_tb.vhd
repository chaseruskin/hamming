-- Testbench for the `decoder` module using file IO and event logging.

library ieee;
use ieee.std_logic_1164.all;

library test;
use test.verb.all;

library std;
use std.textio.all;

library work;
use work.hamm_pkg.all;

entity decoder_tb is 
    generic (
        SIZE : positive := 2
    );
end entity;


architecture sim of decoder_tb is

    -- This record is automatically @generated by Verb.
    -- It is not intended for manual editing.
    type decoder_bfm is record
        enc: logics(SIZE-1 downto 0);
        dec: logics((2**SIZE)-1 downto 0);
    end record;

    signal bfm: decoder_bfm;

    constant DELAY : time := 10 ns;

    file events : text open write_mode is "events.log";
    signal halt : boolean := false;

begin
    -- Instantiate the device-under-test
    dut : entity work.decoder
    generic map (
        SIZE => SIZE
    ) port map (
        enc => bfm.enc,
        dec => bfm.dec
    );

    -- Assert the received outputs match expected model values
    bench: process
        file inputs  : text open read_mode is "inputs.txt";
        file outputs : text open read_mode is "outputs.txt";

        -- This procedure is automatically @generated by Verb.
        -- It is not intended for manual editing.
        procedure send(file i: text) is
            variable row: line;
        begin
            if endfile(i) = false then
                readline(i, row);
                drive(row, bfm.enc);
            end if;
        end procedure;

        -- This procedure is automatically @generated by Verb.
        -- It is not intended for manual editing.
        procedure compare(file e: text; file o: text) is
            variable row: line;
            variable mdl: decoder_bfm;
        begin
            if endfile(o) = false then
                readline(o, row);
                load(row, mdl.dec);
                assert_eq(e, bfm.dec, mdl.dec, "dec");
            end if;
        end procedure;
    begin
        while not endfile(inputs) loop
            -- send a set of inputs to the design
            send(inputs);
            wait for DELAY;
            -- read and check the outputs on the same cycle
            compare(events, outputs);
        end loop;

        -- halt the simulation
        complete(events, halt);
    end process;

end architecture;